yarn add node-sass

webpack and babel will convert sass to css

yarn add react-router-dom

if there are conflicts in version for dependencies
package.json
"resolutions": {
  "babel-jest": "24.7.1"
}

import BrowserRouter in index.js and wrap around <App />

Route
- exact: true or false for exact match
- path: pattern url looking to match
- component

Switch
  Route
  - the moment it sees something match, it will not render the other Routes

props
- history
-- equivalent to use a link but more dynamic
-- can use in componentDidMount
- location: where we are currently, full url
- match

<Link to='/path
- using js to which component to remount/re-render

<button onClick={() => props.history.push('/path)}

match
- allows us to build out nested structure
- it will match the pattern and doesn't care how deeply nested the route is to generate a dynamic path

Route history is only passed into it's first child
- dont prop tunneling
-- passing history down the children til it reaches the child that needs it
-- bad practice cuz there are children that don't need it

withRouter
- higher order component
- function takes a component and transform it into another higherform of itself

export default withRouter(MenuItem)

<div className='directory-menu'>
  { this.state.sections.map(({ title, imageUrl, id, size }) => (
    <MenuItem key={id} title={title} imageUrl={imageUrl} size={size} />
  ))}
</div>
- since the destructured attributes are mapped out the same, we can just use spread
<div className='directory-menu'>
  { this.state.sections.map(({ id, ...otherSectionProps }) => (
    <MenuItem key={id} {...otherSectionProps} />
  ))}
</div>

importing svg
import { ReactComponent as Logo }
- tells create react app that you want a react component that renders SVG rather than its filename

firebase
develop
- create a project
- project overview > web icon
-- register app
-- copy firebaseConfig

yarn add firebase
add firebase.util.js
- configures firebase auth

firebase > authentication > sign-in method > edit google
- enable
- project support email
- save

firestore
- firebase > database > create database
- nosql db
-- giant json
- collection
-- array of things
-- i.e. user collection, cartItems collection

query
const firestore = firebase.firestore();
firestore.collection('users').doc('<userId>').collections('cartItems')
firestore.doc('/users/<userId>/cartItems/...)
- equivalent to the query above to get the document (item)
firestore.collection('/users/<userId>/cartItems')
- to get the collection

firestore
- returns 2 types of objects
- references
-- object that represents the current place in db
-- firestore.doc('/users/:userId)
-- firestore.collection('/users)
- snapshots

documentSnapshot
- .exists
-- check if document exists
- .data()
-- get actual properties json
-- snapshot alone doesn't give any data
-- snapshot.data() will return attributes

firebase
- enable email and password


************************
8. REDUX
************************
REDUX
- good for managing large state
- useful for sharing data btw components
- predictable state management using the 3 principles
1. single source of truth
2. state is read only
3. changes using pure functions

Redux Flow
action (middleware) > root reducer > store (state) > dom change

render a new object so that the component rerender

reducer is just a function that takes (currentState, action)

yarn add redux redux-logger react-redux

pass store into Provider
- app can now access redux

Redux setup
- yarn add redux redux-logger react-redux
- add Provider to index.js
- create redux folder
- root-reducer.js
-- combine all the reducers
- user/
-- user.reducer
** listening on action.type SET_CURRENT_USER and return new state
-- user.actions
** method that returns user base on setuCurrentUser
- store
-- has middleware to accept all the actions before pushing to root-reducer
-- pass into Provider
